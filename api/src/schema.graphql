# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AddDocumentsToChatResponse {
  chat: Chat
  error: String
}

type AdminStatsResponse {
  chatsCount: Float!
  modelsCount: Float!
  usersCount: Float!
}

type AdminUsersResponse {
  hasMore: Boolean!
  total: Float!
  users: [User!]!
}

type ApplicationConfig {
  currentUser: User
  demoMode: Boolean!
  maxChatMessages: Float
  maxChats: Float
  maxImages: Float
  ragEnabled: Boolean
  ragSupported: Boolean
  s3Connected: Boolean
  token: String
}

type AuthResponse {
  token: String!
  user: User!
}

input CallOtherInput {
  messageId: String!
  modelId: String!
}

type CallOtherResponse {
  error: String
  message: Message
}

input ChangePasswordInput {
  currentPassword: String!
  newPassword: String!
}

type Chat {
  chatDocuments: [ChatDocument!]
  createdAt: DateTimeISO!
  description: String
  id: ID!
  imagesCount: Float
  isPristine: Boolean!
  lastBotMessage: String
  lastBotMessageId: String
  maxTokens: Float
  messages: [Message!]
  messagesCount: Float
  modelId: String
  temperature: Float
  title: String!
  tools: [ChatTool!]
  topP: Float
  updatedAt: DateTimeISO!
  user: User
  userId: String
}

type ChatDocument {
  chat: Chat!
  chatId: String!
  document: Document!
  documentId: String!
  id: ID!
}

type ChatTool {
  name: String!
  options: [ChatToolOptions!]
  type: String!
  url: String!
}

type ChatToolCall {
  args: String
  error: String
  name: String!
  type: String
}

type ChatToolCallResult {
  callId: String
  content: String!
  name: String!
}

input ChatToolInput {
  name: String!
  options: [ChatToolOptionsInput!]
  type: String!
}

type ChatToolOptions {
  name: String!
  value: String!
}

input ChatToolOptionsInput {
  name: String!
  value: String!
}

input CreateChatInput {
  description: String
  modelId: String
  systemPrompt: String
  title: String
}

input CreateMessageInput {
  chatId: String!
  content: String!
  documentIds: [String!]
  images: [ImageInput!]
  imagesCount: Float
  maxTokens: Float
  modelId: String
  temperature: Float
  topP: Float
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

type DeleteMessageResponse {
  messages: [DeleteMessageResult!]!
}

type DeleteMessageResult {
  id: String!
  linkedToMessageId: String
}

type Document {
  createdAt: DateTimeISO!
  downloadUrl: String
  embeddingsModelId: String
  fileName: String!
  fileSize: Float!
  id: ID!
  mime: String
  owner: User!
  ownerId: String!
  pagesCount: Float!
  s3key: String
  sha256checksum: String!
  status: String!
  statusInfo: String
  statusProgress: Float
  summary: String
  summaryModelId: String
  updatedAt: DateTimeISO!
}

type DocumentStatusMessage {
  documentId: ID!
  status: String!
  statusInfo: String
  statusProgress: Float
  summary: String
  sync: Boolean
  updatedAt: DateTimeISO
}

type DocumentsResponse {
  documents: [Document!]!
  hasMore: Boolean!
  total: Float!
}

type EditMessageResponse {
  error: String
  message: Message
}

input GetChatsInput {
  limit: Float = 20
  offset: Float = 0
  searchTerm: String
}

input GetCostsInput {
  apiProvider: String!
  endTime: Float
  startTime: Float!
}

input GetDocumentsInput {
  limit: Float = 20
  offset: Float = 0
  searchTerm: String
}

input GetImagesInput {
  limit: Float = 20
  offset: Float = 0
}

input GetMessagesInput {
  chatId: String!
  limit: Float = 20
  offset: Float = 0
}

input GetUsersInput {
  limit: Float = 20
  offset: Float = 0
  searchTerm: String
}

type GqlAmount {
  amount: Float!
  currency: String!
}

type GqlChatsList {
  chats: [Chat!]
  error: String
  hasMore: Boolean!
  total: Float
}

type GqlCostsInfo {
  costs: [GqlServiceCostInfo!]!
  end: DateTimeISO
  error: String
  start: DateTimeISO!
}

type GqlImage {
  chat: Chat!
  createdAt: DateTimeISO!
  fileName: String!
  fileUrl: String!
  id: ID!
  message: Message!
  mimeType: String!
  role: String!
}

type GqlImagesList {
  error: String
  images: [GqlImage!]
  nextPage: Float
  total: Float
}

type GqlMessage {
  chat: MessageChatInfo
  error: String
  message: Message
  streaming: Boolean
  type: String!
}

type GqlMessagesList {
  chat: Chat
  error: String
  hasMore: Boolean
  messages: [Message!]
  total: Float
}

type GqlModelsList {
  error: String
  models: [Model!]
  providers: [GqlProviderInfo!]
  total: Float
}

type GqlProviderInfo {
  costsInfoAvailable: Boolean!
  details: [ProviderDetail!]!
  id: String!
  isConnected: Boolean!
  name: String!
}

type GqlServiceCostInfo {
  amounts: [GqlAmount!]!
  name: String!
  type: String!
}

input ImageInput {
  bytesBase64: String!
  fileName: String!
  mimeType: String!
}

input LoginInput {
  email: String!
  password: String!
}

type Message {
  chat: Chat!
  chatId: String
  content: String!
  createdAt: DateTimeISO
  id: ID!
  linkedMessages: [Message!]
  linkedToMessage: Message!
  linkedToMessageId: String
  metadata: MessageMetadata
  modelId: String!
  modelName: String
  role: String!
  status: String
  statusInfo: String
  updatedAt: DateTimeISO
  user: User
  userId: String
}

type MessageChatInfo {
  imagesCount: Float
  isPristine: Boolean!
  maxTokens: Float
  modelId: String
  temperature: Float
  title: String
  topP: Float
}

type MessageMetadata {
  analysis: String
  documentIds: [ID!]
  relevantsChunks: [MessageRelevantChunk!]
  toolCalls: [ChatToolCall!]
  tools: [ChatToolCallResult!]
  usage: ModelResponseUsage
}

type MessageRelevantChunk {
  content: String!
  documentId: String!
  documentName: String
  id: ID!
  page: Float!
  pageIndex: Float!
  relevance: Float!
}

type Model {
  apiProvider: String!
  createdAt: DateTimeISO!
  description: String
  id: ID!
  imageInput: Boolean!
  isActive: Boolean!
  isCustom: Boolean!
  maxInputTokens: Float
  modelId: String!
  name: String!
  provider: String
  streaming: Boolean!
  tools: [String!]
  type: String!
  updatedAt: DateTimeISO!
  user: User
  userId: String
}

type ModelResponseUsage {
  cacheReadInputTokens: Float
  cacheWriteInputTokens: Float
  inputTokens: Float
  invocationLatency: Float
  outputTokens: Float
}

type Mutation {
  addDocumentsToChat(chatId: ID!, documentIds: [ID!]!): AddDocumentsToChatResponse!
  callOther(input: CallOtherInput!): CallOtherResponse!
  changePassword(input: ChangePasswordInput!): ID!
  createChat(input: CreateChatInput!): Chat!
  createMessage(input: CreateMessageInput!): Message!
  deleteChat(id: ID!): Boolean!
  deleteDocument(id: ID!): Boolean!
  deleteMessage(deleteFollowing: Boolean, id: ID!): DeleteMessageResponse!
  editMessage(content: String!, messageId: ID!): EditMessageResponse!
  login(input: LoginInput!): AuthResponse!
  processDocument(force: Boolean, id: ID!): Document!
  register(input: RegisterInput!): AuthResponse!
  reindexDocument(id: ID!): Document!
  reloadModels: GqlModelsList!
  removeDocumentsFromChat(chatId: ID!, documentIds: [ID!]!): RemoveDocumentsFromChatResponse!
  switchModel(messageId: ID!, modelId: String!): SwitchModelResponse!
  testModel(input: TestModelInput!): Message!
  updateChat(id: ID!, input: UpdateChatInput!): Chat!
  updateModelStatus(input: UpdateModelStatusInput!): Model!
  updateUser(input: UpdateUserInput!): User!
}

type ProviderDetail {
  key: String!
  value: String!
}

type Query {
  appConfig: ApplicationConfig
  chatById(id: ID!): Chat
  getActiveModels: [Model!]!
  getAdminStats: AdminStatsResponse!
  getAllImages(input: GetImagesInput!): GqlImagesList!
  getChatMessages(input: GetMessagesInput!): GqlMessagesList!
  getChats(input: GetChatsInput): GqlChatsList!
  getCosts(input: GetCostsInput!): GqlCostsInfo!
  getDocuments(input: GetDocumentsInput): DocumentsResponse!
  getMessageById(id: String!): Message
  getModels: GqlModelsList!
  getUsers(input: GetUsersInput): AdminUsersResponse!
  refreshToken: AuthResponse!
}

input RegisterInput {
  authProvider: String
  avatarUrl: String
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  recaptchaToken: String
}

type RemoveDocumentsFromChatResponse {
  chat: Chat
  error: String
}

type Subscription {
  documentsStatus(documentIds: [String!]!): [DocumentStatusMessage!]!
  newMessage(chatId: String!): GqlMessage!
}

type SwitchModelResponse {
  error: String
  message: Message
}

input TestModelInput {
  id: String!
  text: String! = "2+2="
}

input UpdateChatInput {
  description: String
  imagesCount: Float
  maxTokens: Float
  modelId: String
  temperature: Float
  title: String
  tools: [ChatToolInput!]
  topP: Float
}

input UpdateModelStatusInput {
  isActive: Boolean!
  modelId: String!
}

input UpdateUserInput {
  avatarUrl: String
  defaultModelId: String
  defaultSystemPrompt: String
  documentSummarizationModelId: String
  documentsEmbeddingsModelId: String
  email: String
  firstName: String
  lastName: String
  settings: UserSettingsInput
}

type User {
  authProvider: String
  avatarUrl: String
  chatsCount: Float
  createdAt: DateTimeISO!
  defaultModelId: String
  defaultSystemPrompt: String
  documentSummarizationModelId: String
  documents: [Document!]
  documentsEmbeddingsModelId: String
  email: String!
  firstName: String!
  githubId: String
  googleId: String
  id: ID!
  lastName: String!
  models: [Model!]
  modelsCount: Float
  role: String!
  settings: UserSettings
  updatedAt: DateTimeISO!
}

type UserSettings {
  awsBedrockAccessKeyId: String
  awsBedrockProfile: String
  awsBedrockRegion: String
  awsBedrockSecretAccessKey: String
  openaiApiAdminKey: String
  openaiApiKey: String
  s3AccessKeyId: String
  s3Endpoint: String
  s3FilesBucketName: String
  s3Profile: String
  s3Region: String
  s3SecretAccessKey: String
  yandexFmApiFolderId: String
  yandexFmApiKey: String
}

input UserSettingsInput {
  awsBedrockAccessKeyId: String
  awsBedrockProfile: String
  awsBedrockRegion: String
  awsBedrockSecretAccessKey: String
  openaiApiAdminKey: String
  openaiApiKey: String
  s3AccessKeyId: String
  s3Endpoint: String
  s3FilesBucketName: String
  s3Profile: String
  s3Region: String
  s3SecretAccessKey: String
  yandexFmApiFolderId: String
  yandexFmApiKey: String
}
