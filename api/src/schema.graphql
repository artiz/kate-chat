# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AddDocumentsToChatResponse {
  chat: Chat
  error: String
}

type AdminStatsResponse {
  chatsCount: Float!
  modelsCount: Float!
  usersCount: Float!
}

type AdminUsersResponse {
  hasMore: Boolean!
  total: Float!
  users: [User!]!
}

"""
API provider for the model
"""
enum ApiProvider {
  AWS_BEDROCK
  OPEN_AI
  YANDEX_FM
}

type ApplicationConfig {
  currentUser: User
  demoMode: Boolean!
  maxChatMessages: Float
  maxChats: Float
  maxImages: Float
  ragEnabled: Boolean
  ragSupported: Boolean
  s3Connected: Boolean
  token: String
}

type AuthResponse {
  token: String!
  user: User!
}

type CallOtherResponse {
  error: String
  message: Message
}

input ChangePasswordInput {
  currentPassword: String!
  newPassword: String!
}

type Chat {
  chatDocuments: [ChatDocument!]
  createdAt: DateTimeISO!
  description: String
  files: [ChatFile!]
  id: ID!
  imagesCount: Float
  isPinned: Boolean!
  isPristine: Boolean!
  lastBotMessage: String
  lastBotMessageId: String
  maxTokens: Float
  messages: [Message!]
  messagesCount: Float
  modelId: String
  systemPrompt: String
  temperature: Float
  title: String!
  tools: [ChatTool!]
  topP: Float
  updatedAt: DateTimeISO!
  user: User
  userId: String
}

type ChatDocument {
  chat: Chat!
  chatId: String!
  document: Document!
  documentId: String!
  id: ID!
}

type ChatFile {
  chat: Chat!
  chatId: String!
  createdAt: DateTimeISO!
  fileName: String
  id: ID!
  message: Message
  messageId: String
  mime: String
  predominantColor: String
  type: ChatFileType!
  updatedAt: DateTimeISO!
  uploadFile: String
  url: String!
}

enum ChatFileType {
  IMAGE
  INLINE_DOCUMENT
  RAG_DOCUMENT
  VIDEO
}

type ChatResultAnnotation {
  endIndex: Float
  source: String
  startIndex: Float
  title: String
  type: String!
}

type ChatTool {
  name: String!
  options: [ChatToolOptions!]
  type: ToolType!
  url: String
}

type ChatToolCall {
  args: String
  error: String
  name: String!
  type: String
}

type ChatToolCallResult {
  callId: String
  content: String!
  name: String!
}

input ChatToolInput {
  name: String
  options: [ChatToolOptionsInput!]
  type: ToolType!
}

type ChatToolOptions {
  name: String!
  value: String!
}

input ChatToolOptionsInput {
  name: String!
  value: String!
}

input CreateChatInput {
  description: String
  modelId: String
  systemPrompt: String
  title: String
}

input CreateMessageInput {
  chatId: String!
  content: String!
  documentIds: [String!]
  images: [ImageInput!]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

type DeleteMessageResponse {
  messages: [DeleteMessageResult!]!
}

type DeleteMessageResult {
  id: String!
  linkedToMessageId: String
}

type Document {
  createdAt: DateTimeISO!
  downloadUrl: String
  downloadUrlMarkdown: String
  embeddingsModelId: String
  fileName: String!
  fileSize: Float!
  id: ID!
  mime: String
  owner: User!
  ownerId: String!
  pagesCount: Float!
  s3key: String
  sha256checksum: String!
  status: String!
  statusInfo: String
  statusProgress: Float
  summary: String
  summaryModelId: String
  updatedAt: DateTimeISO!
}

type DocumentStatusMessage {
  documentId: ID!
  status: String!
  statusInfo: String
  statusProgress: Float
  summary: String
  sync: Boolean
  updatedAt: DateTimeISO
}

type DocumentsResponse {
  documents: [Document!]!
  hasMore: Boolean!
  total: Float!
}

type EditMessageResponse {
  error: String
  message: Message
}

input GetChatsInput {
  from: Float = 0
  limit: Float = 20
  pinned: Boolean
  searchTerm: String
}

input GetCostsInput {
  apiProvider: ApiProvider!
  endTime: Float
  startTime: Float!
}

input GetDocumentsInput {
  limit: Float = 20
  offset: Float = 0
  searchTerm: String
}

input GetImagesInput {
  limit: Float = 20
  offset: Float = 0
}

input GetMessagesInput {
  chatId: String!
  limit: Float = 20
  offset: Float = 0
}

input GetUsersInput {
  limit: Float = 20
  offset: Float = 0
  searchTerm: String
}

type GqlAmount {
  amount: Float!
  currency: String!
}

type GqlChatsList {
  chats: [Chat!]
  error: String
  next: Float
  total: Float
}

type GqlCostsInfo {
  costs: [GqlServiceCostInfo!]!
  end: DateTimeISO
  error: String
  start: DateTimeISO!
}

type GqlImage {
  chat: Chat!
  createdAt: DateTimeISO!
  fileName: String!
  fileUrl: String!
  id: ID!
  message: Message
  mimeType: String!
  role: String!
}

type GqlImagesList {
  error: String
  images: [GqlImage!]
  nextPage: Float
}

type GqlMessage {
  chat: MessageChatInfo
  error: String
  message: Message
  streaming: Boolean
  type: String!
}

type GqlMessagesList {
  chat: Chat
  error: String
  hasMore: Boolean
  messages: [Message!]
  total: Float
}

type GqlModelsList {
  error: String
  models: [Model!]
  providers: [GqlProviderInfo!]
  total: Float
}

type GqlProviderInfo {
  costsInfoAvailable: Boolean!
  details: [ProviderDetail!]!
  id: ApiProvider!
  isConnected: Boolean!
  name: String!
}

type GqlServiceCostInfo {
  amounts: [GqlAmount!]!
  name: String!
  type: String!
}

input ImageInput {
  bytesBase64: String!
  fileName: String!
  mimeType: String!
}

input LoginInput {
  email: String!
  password: String!
}

type Message {
  chat: Chat!
  chatId: String
  content: String!
  createdAt: DateTimeISO
  files: [ChatFile!]
  id: ID!
  linkedMessages: [Message!]
  linkedToMessage: Message!
  linkedToMessageId: String
  metadata: MessageMetadata
  modelId: String
  modelName: String
  role: String!
  status: String
  statusInfo: String
  updatedAt: DateTimeISO
  user: User
  userId: String
}

type MessageChatInfo {
  imagesCount: Float
  isPristine: Boolean!
  maxTokens: Float
  modelId: String!
  temperature: Float
  title: String
  topP: Float
}

type MessageMetadata {
  analysis: String
  annotations: [ChatResultAnnotation!]
  documentIds: [ID!]
  relevantsChunks: [MessageRelevantChunk!]
  requestId: String
  toolCalls: [ChatToolCall!]
  tools: [ChatToolCallResult!]
  usage: ModelResponseUsage
}

type MessageRelevantChunk {
  content: String!
  documentId: String!
  documentName: String
  id: ID!
  page: Float!
  pageIndex: Float!
  relevance: Float!
}

type Model {
  apiProvider: ApiProvider!
  createdAt: DateTimeISO!
  description: String
  features: [ModelFeature!]
  id: ID!
  imageInput: Boolean!
  isActive: Boolean!
  isCustom: Boolean!
  maxInputTokens: Float
  modelId: String!
  name: String!
  provider: String
  streaming: Boolean!
  tools: [ToolType!]
  type: ModelType!
  updatedAt: DateTimeISO!
  user: User
  userId: String
}

"""
Features that can be enabled for the model
"""
enum ModelFeature {
  REASONING
  REQUEST_CANCELLATION
}

type ModelResponseUsage {
  cacheReadInputTokens: Float
  cacheWriteInputTokens: Float
  inputTokens: Float
  invocationLatency: Float
  outputTokens: Float
}

"""
Type of model - chat or embeddings
"""
enum ModelType {
  AUDIO_GENERATION
  CHAT
  EMBEDDING
  IMAGE_GENERATION
  OTHER
  REALTIME
}

type Mutation {
  addDocumentsToChat(chatId: ID!, documentIds: [ID!]!): AddDocumentsToChatResponse!
  callOther(messageId: ID!, modelId: String!): CallOtherResponse!
  changePassword(input: ChangePasswordInput!): ID!
  createChat(input: CreateChatInput!): Chat!
  createMessage(input: CreateMessageInput!): Message!
  deleteChat(id: ID!): Boolean!
  deleteDocument(id: ID!): Boolean!
  deleteMessage(deleteFollowing: Boolean, id: ID!): DeleteMessageResponse!
  editMessage(content: String!, messageId: ID!): EditMessageResponse!
  login(input: LoginInput!): AuthResponse!
  processDocument(force: Boolean, id: ID!): Document!
  register(input: RegisterInput!): AuthResponse!
  reindexDocument(id: ID!): Document!
  reloadModels: GqlModelsList!
  removeDocumentsFromChat(chatId: ID!, documentIds: [ID!]!): RemoveDocumentsFromChatResponse!
  stopMessageGeneration(input: StopMessageGenerationInput!): StopMessageGenerationResponse!
  switchModel(messageId: ID!, modelId: String!): SwitchModelResponse!
  testModel(input: TestModelInput!): Message!
  updateChat(id: ID!, input: UpdateChatInput!): Chat!
  updateModelStatus(input: UpdateModelStatusInput!): Model!
  updateUser(input: UpdateUserInput!): User!
}

type ProviderDetail {
  key: String!
  value: String!
}

type Query {
  appConfig: ApplicationConfig
  chatById(id: ID!): Chat
  findPristineChat: Chat
  getActiveModels: [Model!]!
  getAdminStats: AdminStatsResponse!
  getAllImages(input: GetImagesInput!): GqlImagesList!
  getChatMessages(input: GetMessagesInput!): GqlMessagesList!
  getChats(input: GetChatsInput): GqlChatsList!
  getCosts(input: GetCostsInput!): GqlCostsInfo!
  getDocuments(input: GetDocumentsInput): DocumentsResponse!
  getMessageById(id: String!): Message
  getModels: GqlModelsList!
  getUsers(input: GetUsersInput): AdminUsersResponse!
  refreshToken: AuthResponse!
}

input RegisterInput {
  authProvider: String
  avatarUrl: String
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  recaptchaToken: String
}

type RemoveDocumentsFromChatResponse {
  chat: Chat
  error: String
}

input StopMessageGenerationInput {
  messageId: String!
  requestId: String!
}

type StopMessageGenerationResponse {
  error: String
  messageId: String
  requestId: String
}

type Subscription {
  documentsStatus(documentIds: [String!]!): [DocumentStatusMessage!]!
  newMessage(chatId: String!): GqlMessage!
}

type SwitchModelResponse {
  error: String
  message: Message
}

input TestModelInput {
  id: String!
  text: String! = "2+2="
}

"""
Type of tool that can be used in chat
"""
enum ToolType {
  CODE_INTERPRETER
  MCP
  WEB_SEARCH
}

input UpdateChatInput {
  description: String
  imagesCount: Float
  isPinned: Boolean
  maxTokens: Float
  modelId: String
  systemPrompt: String
  temperature: Float
  title: String
  tools: [ChatToolInput!]
  topP: Float
}

input UpdateModelStatusInput {
  isActive: Boolean!
  modelId: String!
}

input UpdateUserInput {
  avatarUrl: String
  defaultImagesCount: Float
  defaultMaxTokens: Float
  defaultModelId: String
  defaultSystemPrompt: String
  defaultTemperature: Float
  defaultTopP: Float
  documentSummarizationModelId: String
  documentsEmbeddingsModelId: String
  email: String
  firstName: String
  lastName: String
  settings: UserSettingsInput
}

type User {
  authProvider: String
  avatarUrl: String
  chatsCount: Float
  createdAt: DateTimeISO!
  defaultImagesCount: Float
  defaultMaxTokens: Float
  defaultModelId: String
  defaultSystemPrompt: String
  defaultTemperature: Float
  defaultTopP: Float
  documentSummarizationModelId: String
  documents: [Document!]
  documentsEmbeddingsModelId: String
  email: String!
  firstName: String!
  githubId: String
  googleId: String
  id: ID!
  lastName: String!
  microsoftId: String
  models: [Model!]
  modelsCount: Float
  role: String!
  settings: UserSettings
  updatedAt: DateTimeISO!
}

type UserSettings {
  awsBedrockAccessKeyId: String
  awsBedrockProfile: String
  awsBedrockRegion: String
  awsBedrockSecretAccessKey: String
  openaiApiAdminKey: String
  openaiApiKey: String
  s3AccessKeyId: String
  s3Endpoint: String
  s3FilesBucketName: String
  s3Profile: String
  s3Region: String
  s3SecretAccessKey: String
  yandexFmApiFolderId: String
  yandexFmApiKey: String
}

input UserSettingsInput {
  awsBedrockAccessKeyId: String
  awsBedrockProfile: String
  awsBedrockRegion: String
  awsBedrockSecretAccessKey: String
  openaiApiAdminKey: String
  openaiApiKey: String
  s3AccessKeyId: String
  s3Endpoint: String
  s3FilesBucketName: String
  s3Profile: String
  s3Region: String
  s3SecretAccessKey: String
  yandexFmApiFolderId: String
  yandexFmApiKey: String
}
